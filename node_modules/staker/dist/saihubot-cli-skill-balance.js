"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.skills = exports.skillGetXdaiBlance = exports.skillGetValidatorBlance = exports.skillGetBlance = void 0;

var _react = _interopRequireWildcard(require("react"));

var _ethScan = require("@mycrypto/eth-scan");

var _ink = require("ink");

var _inkTable = _interopRequireDefault(require("ink-table"));

var _i18n = require("saihubot-cli-adapter/dist/i18n");

var _utils = require("./utils");

var _saihubotCliSkillChain = require("./saihubot-cli-skill-chain");

var _i18n2 = require("./i18n");

var _token = require("./token");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const balanceI18n = {
  'en': {
    query: 'Query current balance...',
    token: 'Symbol',
    balance: 'Balance',
    source: 'Source',
    needAddr: 'Please pass the address or define SAIHUBOT_ETH_ADDR first'
  },
  'zh_TW': {
    query: '查詢餘額中...',
    token: '幣種',
    balance: '餘額',
    source: '來源',
    needAddr: '請傳入地址或是預先定義 SAIHUBOT_ETH_ADDR 參數'
  },
  props: ['balance', 'usdt']
};

const EthBalances = ({
  addresses,
  fetch
}) => {
  const [balance, setBalance] = (0, _react.useState)([]);
  if (!addresses) return null;
  const data = [];
  (0, _react.useEffect)(() => {
    async function fetchEthBalance() {
      const ethBalances = await (0, _ethScan.getEtherBalances)((0, _utils.getNodeURL)(), addresses);
      Object.values(ethBalances).map(val => {
        if (val === 0n) return;
        data.push({
          [(0, _i18n.t)('token', {
            i18n: balanceI18n
          })]: 'ETH',
          [(0, _i18n.t)('balance', {
            i18n: balanceI18n
          })]: (Number(val) / 10 ** 18).toFixed(8),
          [(0, _i18n.t)('source', {
            i18n: balanceI18n
          })]: ''
        });
      });
      setBalance([...balance, ...data]);
    }

    async function fetchTokenBalance() {
      const tokenBalances = await (0, _ethScan.getTokensBalances)((0, _utils.getNodeURL)(), addresses, Object.keys(_token.tokenMap));
      Object.keys(tokenBalances).map(addr => Object.entries(tokenBalances[addr]).map(([key, val]) => {
        if (val === 0n) return;
        const token = _token.tokenMap[key];
        data.push({
          Symbol: token.symbol,
          Balance: (Number(val) / 10 ** token.decimals).toFixed(4),
          [(0, _i18n.t)('source', {
            i18n: balanceI18n
          })]: token.source || ''
        });
      }));
      setBalance([...balance, ...data]);
    }

    if (addresses) {
      fetchEthBalance();
      fetchTokenBalance();
    }
  }, [addresses, fetch]);
  return balance.length > 0 ? /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_ink.Text, null, (0, _i18n.t)('accountBalance', {
    i18n: _i18n2.i18nValidator
  })), /*#__PURE__*/_react.default.createElement(_inkTable.default, {
    data: balance
  })) : /*#__PURE__*/_react.default.createElement(_ink.Text, null, (0, _i18n.t)('query', {
    i18n: balanceI18n
  }));
}; // support multiple validators balance by comma (without space)


const ValidatorBalances = ({
  validator,
  fetch
}) => {
  const [balance, setBalance] = (0, _react.useState)([]);
  if (!validator) return null;
  let validators = typeof validator === 'string' && validator.indexOf(',') > -1 ? validator.split(',').map(index => index.trim()) : [validator + ''];
  const isOverflow = validators.length > 100;
  const data = [];
  (0, _react.useEffect)(() => {
    if (isOverflow) {
      validators = validators.slice(0, 100);
    }

    async function fetchValidatorBalance() {
      fetch(`https://beaconcha.in/api/v1/validator/${validators.join(',')}`).then(response => response.json()).then(json => {
        const arrData = Array.isArray(json.data) ? json.data : [json.data];
        json.data && Object.values(arrData).map(validator => {
          validator.balance && data.push({
            Symbol: 'ETH',
            Balance: `${Number(validator.balance) / 10 ** 9}`,
            Index: validator.validatorindex
          });
        });
        setBalance(data);
      });
    }

    validator && fetchValidatorBalance();
  }, [validator, fetch]);
  return balance.length > 0 ? /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_ink.Text, null, (0, _i18n.t)('validatorBalance', {
    i18n: _i18n2.i18nValidator
  })), /*#__PURE__*/_react.default.createElement(_ink.Text, null, isOverflow ? '(Only shows the first 100 validators)' : ''), /*#__PURE__*/_react.default.createElement(_inkTable.default, {
    data: balance
  })) : /*#__PURE__*/_react.default.createElement(_ink.Text, null, (0, _i18n.t)('query', {
    i18n: _i18n2.i18nValidator
  }));
};

const XdaiBalances = ({
  addresses,
  fetch
}) => {
  const [balance, setBalance] = (0, _react.useState)([]);
  const data = [];
  (0, _react.useEffect)(() => {
    async function fetchXdaiBalance() {
      const tokens = Object.keys(_token.xdaiTokenMap);

      for (let i = 0; i < addresses.length; i++) {
        const json = await (0, _utils.xdaiFetch)(fetch, (0, _saihubotCliSkillChain.rpcEthBalance)(addresses[i]));
        const val = json.result === 0x0 ? 0 : Number(json.result) / 10 ** 18;

        if (val > 0) {
          data.push({
            Symbol: 'xDai',
            Balance: val,
            [(0, _i18n.t)('source', {
              i18n: balanceI18n
            })]: ''
          });
        }

        for (let j = 0; j < tokens.length; j++) {
          const currentTokenAddr = tokens[j];
          const tokenInfo = _token.xdaiTokenMap[currentTokenAddr];
          const tokenJson = await (0, _utils.xdaiFetch)(fetch, (0, _saihubotCliSkillChain.rpcTokenBalance)(addresses[i], currentTokenAddr));

          if (tokenJson.result !== '0x0000000000000000000000000000000000000000000000000000000000000000') {
            data.push({
              Symbol: tokenInfo.symbol,
              Balance: Number(tokenJson.result) / 10 ** tokenInfo.decimals,
              [(0, _i18n.t)('source', {
                i18n: balanceI18n
              })]: ''
            });
          }
        }
      }

      setBalance([...balance, ...data]);
    }

    addresses && fetchXdaiBalance();
  }, [addresses, fetch]);
  return balance.length > 0 ? /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_ink.Text, null, (0, _i18n.t)('xdaiBalance', {
    i18n: _i18n2.i18nValidator
  })), /*#__PURE__*/_react.default.createElement(_inkTable.default, {
    data: balance
  })) : /*#__PURE__*/_react.default.createElement(_ink.Text, null, (0, _i18n.t)('query', {
    i18n: _i18n2.i18nValidator
  }));
}; // support multiple account balance by comma (without space)
// also shows validator balances


const Balances = ({
  address,
  fetch
}) => {
  const [validator, setValidator] = (0, _react.useState)('');
  const addresses = address.indexOf(',') > -1 ? address.split(',').map(addr => addr.trim()) : [address];
  (0, _react.useEffect)(() => {
    async function fetchValidators() {
      for (let i = 0; i < addresses.length; i++) {
        const json = await fetch(`https://beaconcha.in/api/v1/validator/eth1/${addresses[i]}`).then(response => response.json());
        const validators = Array.isArray(json.data) ? json.data : [json.data];

        if (validators && validators.length > 0) {
          const data = validators.length === 1 ? validators[0].validatorindex : validators.filter(data => data.validatorindex !== 0).map(data => data.validatorindex).join(',');
          setValidator(validator ? validator + ',' + data : data);
        }
      }
    }

    if (address) {
      fetchValidators();
    }
  }, [address, fetch]);
  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(EthBalances, {
    addresses: addresses,
    fetch: fetch
  }), /*#__PURE__*/_react.default.createElement(_ink.Text, null, " "), /*#__PURE__*/_react.default.createElement(ValidatorBalances, {
    validator: validator,
    fetch: fetch
  }), /*#__PURE__*/_react.default.createElement(_ink.Text, null, " "), /*#__PURE__*/_react.default.createElement(XdaiBalances, {
    addresses: addresses,
    fetch: fetch
  }));
};
/**
 * Get ETH and stable coins balance of [address].
 * Includes the stable token load in AAVE and Compound
 *
 * can pass the address, or pre-define the
 * SAIHUBOT_ETH_ADDR environment variable
 */


const skillGetBlance = {
  name: 'balance',
  help: '💰balance - Show [address] balance',
  requirements: {
    addons: ['fetch']
  },
  rule: /(^balance )(.*)|^balance$/i,
  action: function (robot, msg) {
    let addr = '';

    if (msg[2] === undefined) {
      addr = (0, _utils.getConfig)('ETH_ADDR', '');

      if (addr.trim() === '') {
        robot.send((0, _i18n.t)('needAddr', {
          i18n: balanceI18n
        }));
        robot.render();
        return;
      }
    }

    const parsedAddr = addr.trim() || msg[2];
    robot.sendComponent( /*#__PURE__*/_react.default.createElement(Balances, {
      address: parsedAddr,
      fetch: robot.addons.fetch
    }));
    robot.render();
  }
};
/**
 * Get Validator's balance of [key].
 *
 * can pass the validator key, or pre-define the
 * SAIHUBOT_VALIDATOR environment variable
 */

exports.skillGetBlance = skillGetBlance;
const skillGetValidatorBlance = {
  name: 'balance-validator',
  help: '💰balance-validator|balance-eth2 - Show Validator\'s balance of [key]',
  requirements: {
    addons: ['fetch']
  },
  rule: /(^balance-(validator|eth2) )(.*)|^balance-(validator|eth2)$/i,
  action: function (robot, msg) {
    let validator = '';

    if (msg[3] === undefined) {
      validator = (0, _utils.getConfig)('VALIDATOR', '');

      if (validator === '') {
        robot.send((0, _i18n.t)('needAddr', {
          i18n: _i18n2.i18nValidator
        }));
        robot.render();
        return;
      }
    }

    const data = validator || msg[3];
    robot.sendComponent( /*#__PURE__*/_react.default.createElement(ValidatorBalances, {
      validator: data,
      fetch: robot.addons.fetch
    }));
    robot.render();
  }
};
/**
 * Get balance of [addr] on xDai Chain.
 *
 * can pass the address, or pre-define the
 * SAIHUBOT_ADDR environment variable
 */

exports.skillGetValidatorBlance = skillGetValidatorBlance;
const skillGetXdaiBlance = {
  name: 'balance-xdai',
  help: '💰balance-xdai - Show address balance on xDai chain',
  requirements: {
    addons: ['fetch']
  },
  rule: /(^balance-xdai )(.*)|^balance-xdai$/i,
  action: function (robot, msg) {
    let addr = '';

    if (msg[2] === undefined) {
      addr = (0, _utils.getConfig)('ETH_ADDR', '');

      if (addr.trim() === '') {
        robot.send((0, _i18n.t)('needAddr', {
          i18n: balanceI18n
        }));
        robot.render();
        return;
      }
    }

    const parsedAddr = addr.trim() || msg[2];
    robot.sendComponent( /*#__PURE__*/_react.default.createElement(XdaiBalances, {
      address: parsedAddr,
      fetch: robot.addons.fetch
    }));
    robot.render();
  }
};
exports.skillGetXdaiBlance = skillGetXdaiBlance;
const skills = [skillGetBlance, skillGetValidatorBlance, skillGetXdaiBlance];
exports.skills = skills;
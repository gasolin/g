import{waffle,ethers}from"@nomiclabs/buidler";import ERC20Artifact from"openzeppelin-solidity/build/contracts/IERC20.json";import BalanceScannerArtifact from"../artifacts/BalanceScanner.json";import{getEtherBalances,getTokenBalances,getTokensBalance,getTokensBalances}from"./eth-scan";const{deployContract,deployMockContract,loadFixture}=waffle;// eslint-disable-next-line jest/no-export
export const fixture=async(a,b)=>{const c=a[0],d=await deployContract(c,BalanceScannerArtifact),e=await deployMockContract(c,ERC20Artifact.abi),f=await Promise.all(a.slice(1).map(a=>a.getAddress()));return{contract:d,signers:a,addresses:f,provider:b,token:e}};describe("eth-scan",()=>{describe("getEtherBalances",()=>{it("returns the ether balances for multiple addresses as a BalanceMap",async()=>{const{contract:a,addresses:b}=await loadFixture(fixture),c=await getEtherBalances(ethers.provider,b,{contractAddress:a.address});for(const a of b){const b=BigInt((await ethers.provider.getBalance(a)).toHexString());expect(b).toBe(c[a])}})}),describe("getTokenBalances",()=>{it("returns the token balances of one token, for multiple addresses",async()=>{const{contract:a,addresses:b,token:c}=await loadFixture(fixture);await c.mock.balanceOf.returns("1000");const d=await getTokenBalances(ethers.provider,b,c.address,{contractAddress:a.address});for(const a of b)expect(d[a]).toBe(1000n)}),it("does not throw for invalid contracts",async()=>{const{contract:a,addresses:b,token:c}=await loadFixture(fixture);await expect(()=>getTokenBalances(ethers.provider,b,c.address,{contractAddress:a.address})).not.toThrow()})}),describe("getTokensBalances",()=>{it("returns multiple token balances, for multiple addresses",async()=>{const{contract:a,signers:b,addresses:c}=await loadFixture(fixture),d=await deployMockContract(b[0],ERC20Artifact.abi);await d.mock.balanceOf.returns("1000");const e=await deployMockContract(b[0],ERC20Artifact.abi);await e.mock.balanceOf.returns("1");const f=await getTokensBalances(ethers.provider,c,[d.address,e.address],{contractAddress:a.address});for(const a of c)expect(Object.keys(f[a])).toHaveLength(2),expect(Object.keys(f[a])[0]).toBe(d.address),expect(Object.keys(f[a])[1]).toBe(e.address),expect(f[a][d.address]).toBe(1000n),expect(f[a][e.address]).toBe(1n)}),it("does not throw for invalid contracts",async()=>{const{contract:a,signers:b,addresses:c}=await loadFixture(fixture),d=await deployMockContract(b[0],ERC20Artifact.abi),e=await deployMockContract(b[0],ERC20Artifact.abi);await expect(()=>getTokensBalances(ethers.provider,c,[d.address,e.address],{contractAddress:a.address})).not.toThrow()})}),describe("getTokensBalance",()=>{it("returns multiple token balances for a single address",async()=>{const{contract:a,signers:b,addresses:c}=await loadFixture(fixture),d=await deployMockContract(b[0],ERC20Artifact.abi);await d.mock.balanceOf.returns("1000");const e=await deployMockContract(b[0],ERC20Artifact.abi);await e.mock.balanceOf.returns("1");const f=await getTokensBalance(ethers.provider,c[0],[d.address,e.address],{contractAddress:a.address});expect(Object.keys(f)).toHaveLength(2),expect(Object.keys(f)[0]).toBe(d.address),expect(Object.keys(f)[1]).toBe(e.address),expect(f[d.address]).toBe(1000n),expect(f[e.address]).toBe(1n)}),it("does not throw for invalid contracts",async()=>{const{contract:a,signers:b,addresses:c}=await loadFixture(fixture),d=await deployMockContract(b[0],ERC20Artifact.abi),e=await deployMockContract(b[0],ERC20Artifact.abi);await expect(()=>getTokensBalance(ethers.provider,c[0],[d.address,e.address],{contractAddress:a.address})).not.toThrow()})})});
//# sourceMappingURL=eth-scan.test.js.map
{"version":3,"sources":["../../../src/providers/web3.test.ts"],"names":["ethers","waffle","Web3","ETHER_BALANCES_ID","ETHER_BALANCES_TYPE","TOKEN_BALANCES_ID","TOKEN_BALANCES_TYPE","fixture","decode","encodeWithId","callWithWeb3","isWeb3Provider","jest","mock","loadFixture","describe","it","expect","currentProvider","send","toBe","web3","provider","connection","url","contract","addresses","data","response","address","decoded","i","length","balance","BigInt","getBalance","toHexString","token","balanceOf","returns"],"mappings":"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","sourcesContent":["import { ethers, waffle } from '@nomiclabs/buidler';\nimport Web3 from 'web3';\nimport { ETHER_BALANCES_ID, ETHER_BALANCES_TYPE, TOKEN_BALANCES_ID, TOKEN_BALANCES_TYPE } from '../constants';\nimport { fixture } from '../eth-scan.test';\nimport { decode, encodeWithId } from '../utils';\nimport { callWithWeb3, isWeb3Provider, Web3ProviderLike } from './web3';\n\njest.mock('web3');\n\nconst { loadFixture } = waffle;\n\ndescribe('isWeb3Provider', () => {\n  it('checks if a provider is an HTTP provider', () => {\n    expect(\n      isWeb3Provider({\n        currentProvider: {\n          send(): void {\n            /* noop */\n          }\n        }\n      })\n    ).toBe(true);\n    expect(isWeb3Provider({})).toBe(false);\n  });\n});\n\ndescribe('callWithWeb3', () => {\n  const web3 = new Web3(ethers.provider.connection.url);\n\n  it('gets the Ether balances from the contract', async () => {\n    const { contract, addresses } = await loadFixture(fixture);\n\n    const data = encodeWithId(ETHER_BALANCES_ID, ETHER_BALANCES_TYPE, addresses);\n    const response = await callWithWeb3((web3 as unknown) as Web3ProviderLike, contract.address, data);\n\n    const decoded = decode<[Array<bigint>]>(['uint256[]'], response)[0];\n\n    for (let i = 0; i < addresses.length; i++) {\n      const balance = BigInt((await ethers.provider.getBalance(addresses[i])).toHexString());\n      expect(balance).toBe(decoded[i]);\n    }\n  });\n\n  it('gets the token balances from the contract', async () => {\n    const { contract, addresses, token } = await loadFixture(fixture);\n    await token.mock.balanceOf.returns('1000');\n\n    const data = encodeWithId(TOKEN_BALANCES_ID, TOKEN_BALANCES_TYPE, addresses, token.address);\n    const response = await callWithWeb3((web3 as unknown) as Web3ProviderLike, contract.address, data);\n\n    const decoded = decode<[Array<bigint>]>(['uint256[]'], response)[0];\n\n    for (let i = 0; i < addresses.length; i++) {\n      expect(decoded[i]).toBe(1000n);\n    }\n  });\n});\n"],"file":"web3.test.js"}
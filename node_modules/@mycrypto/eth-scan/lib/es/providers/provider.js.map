{"version":3,"sources":["../../../src/providers/provider.ts"],"names":["callWithEthers","isEthersProvider","callWithHttp","isHttpProvider","callWithWeb3","isWeb3Provider","call","provider","contractAddress","data","Error"],"mappings":"AAAA,OAASA,cAAT,CAA6CC,gBAA7C,KAAqE,UAArE,CACA,OAASC,YAAT,CAAyCC,cAAzC,KAA+D,QAA/D,CACA,OAASC,YAAT,CAAuBC,cAAvB,KAA+D,QAA/D,CAIA;;;;;;;;GASA,MAAO,MAAMC,CAAAA,IAAI,CAAG,MAAOC,CAAP,CAA+BC,CAA/B,CAAwDC,CAAxD,GAA0F,CAC5G,GAAIR,gBAAgB,CAACM,CAAD,CAApB,CACE,MAAOP,CAAAA,cAAc,CAACO,CAAD,CAAWC,CAAX,CAA4BC,CAA5B,CAArB,CAGF,GAAIN,cAAc,CAACI,CAAD,CAAlB,CACE,MAAOL,CAAAA,YAAY,CAACK,CAAD,CAAWC,CAAX,CAA4BC,CAA5B,CAAnB,CAGF,GAAIJ,cAAc,CAACE,CAAD,CAAlB,CACE,MAAOH,CAAAA,YAAY,CAACG,CAAD,CAAWC,CAAX,CAA4BC,CAA5B,CAAnB,CAGF,KAAM,IAAIC,CAAAA,KAAJ,CAAU,4BAAV,CACP,CAdM","sourcesContent":["import { callWithEthers, EthersProviderLike, isEthersProvider } from './ethers';\nimport { callWithHttp, HttpProviderLike, isHttpProvider } from './http';\nimport { callWithWeb3, isWeb3Provider, Web3ProviderLike } from './web3';\n\nexport type ProviderLike = HttpProviderLike | EthersProviderLike | Web3ProviderLike;\n\n/**\n * Send a call with the data, using the specified provider. If the provider is not a valid provider type (e.g. not a\n * Ethers.js provider, URL or Web3 provider), this will throw an error.\n *\n * @param {ProviderLike} provider\n * @param {string} contractAddress\n * @param {string} data\n * @return {Promise<Buffer>}\n */\nexport const call = async (provider: ProviderLike, contractAddress: string, data: string): Promise<Buffer> => {\n  if (isEthersProvider(provider)) {\n    return callWithEthers(provider, contractAddress, data);\n  }\n\n  if (isHttpProvider(provider)) {\n    return callWithHttp(provider, contractAddress, data);\n  }\n\n  if (isWeb3Provider(provider)) {\n    return callWithWeb3(provider, contractAddress, data);\n  }\n\n  throw new Error('Invalid provider specified');\n};\n"],"file":"provider.js"}
import{ethers,waffle}from"@nomiclabs/buidler";import{ETHER_BALANCES_ID,ETHER_BALANCES_TYPE,TOKEN_BALANCES_ID,TOKEN_BALANCES_TYPE}from"../constants";import{fixture}from"../eth-scan.test";import{decode,encodeWithId}from"../utils";import{callWithEthers,isEthersProvider}from"./ethers";const{loadFixture}=waffle;describe("isEthersProvider",()=>{it("checks if a provider is an Ethers.js provider",()=>{expect(isEthersProvider(ethers.provider)).toBe(!0),expect(isEthersProvider({})).toBe(!1)})}),describe("callWithEthers",()=>{it("gets the Ether balances from the contract",async()=>{const{contract:a,addresses:b}=await loadFixture(fixture),c=encodeWithId(ETHER_BALANCES_ID,ETHER_BALANCES_TYPE,b),d=await callWithEthers(ethers.provider,a.address,c),e=decode(["uint256[]"],d)[0];for(let a=0;a<b.length;a++){const c=BigInt((await ethers.provider.getBalance(b[a])).toHexString());expect(c).toBe(e[a])}}),it("gets the token balances from the contract",async()=>{const{contract:a,addresses:b,token:c}=await loadFixture(fixture);await c.mock.balanceOf.returns("1000");const d=encodeWithId(TOKEN_BALANCES_ID,TOKEN_BALANCES_TYPE,b,c.address),e=await callWithEthers(ethers.provider,a.address,d),f=decode(["uint256[]"],e)[0];for(let a=0;a<b.length;a++)expect(f[a]).toBe(1000n)})});
//# sourceMappingURL=ethers.test.js.map
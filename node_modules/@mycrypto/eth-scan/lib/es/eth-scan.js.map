{"version":3,"sources":["../../src/eth-scan.ts"],"names":["BATCH_SIZE","CONTRACT_ADDRESS","ETHER_BALANCES_ID","ETHER_BALANCES_TYPE","TOKEN_BALANCES_ID","TOKEN_BALANCES_TYPE","TOKENS_BALANCE_ID","TOKENS_BALANCE_TYPE","TOKENS_BALANCES_ID","TOKENS_BALANCES_TYPE","call","batch","decode","encodeWithId","getEtherBalances","provider","addresses","options","contractAddress","batchSize","balances","batchedAddresses","data","toBalanceMap","getTokenBalances","tokenAddress","getTokensBalances","tokenAddresses","toNestedBalanceMap","getTokensBalance","address","reduce","current","next","index"],"mappings":"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","sourcesContent":["import {\n  BATCH_SIZE,\n  CONTRACT_ADDRESS,\n  ETHER_BALANCES_ID,\n  ETHER_BALANCES_TYPE,\n  TOKEN_BALANCES_ID,\n  TOKEN_BALANCES_TYPE,\n  TOKENS_BALANCE_ID,\n  TOKENS_BALANCE_TYPE,\n  TOKENS_BALANCES_ID,\n  TOKENS_BALANCES_TYPE\n} from './constants';\nimport { call, ProviderLike } from './providers';\nimport { batch, decode, encodeWithId } from './utils';\n\n/**\n * An object that contains the address (key) and balance or balance (value).\n */\nexport interface BalanceMap<T = bigint> {\n  [key: string]: T;\n}\n\nexport interface EthScanOptions {\n  /**\n   * The address of the contract to use. Defaults to 0xbb4AAaF8cAA1A575B43E7673e5b155C1c5A8BC13.\n   */\n  contractAddress?: string;\n\n  /**\n   * It's not possible to check thousands of addresses at the same time, due to gas limitations.\n   * Calls are split per `batchSize` addresses, by default set to 1000.\n   */\n  batchSize?: number;\n}\n\n/**\n * Get the Ether balances for the addresses specified.\n *\n * @param {ProviderLike} provider\n * @param {string[]} addresses\n * @param {EthScanOptions} options\n * @return {Promise<BalanceMap>}\n */\nexport const getEtherBalances = async (\n  provider: ProviderLike,\n  addresses: string[],\n  options?: EthScanOptions\n): Promise<BalanceMap> => {\n  const contractAddress = options?.contractAddress ?? CONTRACT_ADDRESS;\n  const batchSize = options?.batchSize ?? BATCH_SIZE;\n\n  const balances = await batch(\n    async (batchedAddresses: string[]) => {\n      const data = encodeWithId(ETHER_BALANCES_ID, ETHER_BALANCES_TYPE, batchedAddresses);\n\n      return decode<[Array<bigint>]>(['uint256[]'], await call(provider, contractAddress, data))[0];\n    },\n    batchSize,\n    addresses\n  );\n\n  return toBalanceMap(addresses, balances);\n};\n\n/**\n * Get the ERC-20 token balances of the token with the address `tokenAddress` for the addresses\n * specified.\n *\n * @param {ProviderLike} provider\n * @param {string[]} addresses\n * @param {string} tokenAddress\n * @param {EthScanOptions} options\n * @return {Promise<BalanceMap>}\n */\nexport const getTokenBalances = async (\n  provider: ProviderLike,\n  addresses: string[],\n  tokenAddress: string,\n  options?: EthScanOptions\n): Promise<BalanceMap> => {\n  const contractAddress = options?.contractAddress ?? CONTRACT_ADDRESS;\n  const batchSize = options?.batchSize ?? BATCH_SIZE;\n\n  const balances = await batch(\n    async (batchedAddresses: string[]) => {\n      const data = encodeWithId(TOKEN_BALANCES_ID, TOKEN_BALANCES_TYPE, batchedAddresses, tokenAddress);\n\n      return decode<[Array<bigint>]>(['uint256[]'], await call(provider, contractAddress, data))[0];\n    },\n    batchSize,\n    addresses\n  );\n\n  return toBalanceMap(addresses, balances);\n};\n\n/**\n * Get the ERC-20 token balances for multiple contracts, for multiple addresses. Note that this may fail if there are\n * too many addresses or tokens, and the batch size is too large.\n *\n * @param {ProviderLike} provider\n * @param {string[]} addresses\n * @param {string[]} tokenAddresses\n * @param {EthScanOptions} options\n * @return {Promise<BalanceMap<BalanceMap>>}\n */\nexport const getTokensBalances = async (\n  provider: ProviderLike,\n  addresses: string[],\n  tokenAddresses: string[],\n  options?: EthScanOptions\n): Promise<BalanceMap<BalanceMap>> => {\n  const contractAddress = options?.contractAddress ?? CONTRACT_ADDRESS;\n  const batchSize = options?.batchSize ?? BATCH_SIZE;\n\n  const balances = await batch<Array<bigint>>(\n    async (batchedAddresses: string[]) => {\n      const data = encodeWithId(TOKENS_BALANCES_ID, TOKENS_BALANCES_TYPE, batchedAddresses, tokenAddresses);\n\n      return decode<[Array<Array<bigint>>]>(['uint256[][]'], await call(provider, contractAddress, data))[0];\n    },\n    batchSize,\n    addresses\n  );\n\n  return toNestedBalanceMap(addresses, tokenAddresses, balances);\n};\n\n/**\n * Get the ERC-20 token balance of the tokens with the addresses `tokenAddresses` for the single\n * address specified.\n *\n * @param {ProviderLike} provider\n * @param {string} address\n * @param {string[]} tokenAddresses\n * @param {EthScanOptions} options\n * @return {Promise<BalanceMap>}\n */\nexport const getTokensBalance = async (\n  provider: ProviderLike,\n  address: string,\n  tokenAddresses: string[],\n  options?: EthScanOptions\n): Promise<BalanceMap> => {\n  const contractAddress = options?.contractAddress ?? CONTRACT_ADDRESS;\n  const batchSize = options?.batchSize ?? BATCH_SIZE;\n\n  const balances = await batch(\n    async (batchedAddresses: string[]) => {\n      const data = encodeWithId(TOKENS_BALANCE_ID, TOKENS_BALANCE_TYPE, address, batchedAddresses);\n\n      return decode<[Array<bigint>]>(['uint256[]'], await call(provider, contractAddress, data))[0];\n    },\n    batchSize,\n    tokenAddresses\n  );\n\n  return toBalanceMap(tokenAddresses, balances);\n};\n\n/**\n * Get a balance map from an array of addresses and an array of balances.\n *\n * @param {string[]} addresses\n * @param {bigint[]} balances\n * @return {BalanceMap}\n */\nexport const toBalanceMap = (addresses: string[], balances: Array<bigint>): BalanceMap => {\n  return balances.reduce<BalanceMap>((current, next, index) => {\n    return {\n      ...current,\n      [addresses[index]]: next\n    };\n  }, {});\n};\n\n/**\n * Get a nested balance map from an array of addresses, token addresses, and balances.\n *\n * @param {string[]} addresses\n * @param {bigint[]} tokenAddresses\n * @param {BalanceMap<BalanceMap>} balances\n */\nexport const toNestedBalanceMap = (\n  addresses: string[],\n  tokenAddresses: string[],\n  balances: Array<Array<bigint>>\n): BalanceMap<BalanceMap> => {\n  return balances.reduce<BalanceMap<BalanceMap>>((current, next, index) => {\n    return {\n      ...current,\n      [addresses[index]]: toBalanceMap(tokenAddresses, next)\n    };\n  }, {});\n};\n"],"file":"eth-scan.js"}
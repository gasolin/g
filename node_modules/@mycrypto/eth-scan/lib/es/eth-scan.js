import{BATCH_SIZE,CONTRACT_ADDRESS,ETHER_BALANCES_ID,ETHER_BALANCES_TYPE,TOKEN_BALANCES_ID,TOKEN_BALANCES_TYPE,TOKENS_BALANCE_ID,TOKENS_BALANCE_TYPE,TOKENS_BALANCES_ID,TOKENS_BALANCES_TYPE}from"./constants";import{call}from"./providers";import{batch,decode,encodeWithId}from"./utils";/**
 * An object that contains the address (key) and balance or balance (value).
 */ /**
 * Get the Ether balances for the addresses specified.
 *
 * @param {ProviderLike} provider
 * @param {string[]} addresses
 * @param {EthScanOptions} options
 * @return {Promise<BalanceMap>}
 */export const getEtherBalances=async(a,b,c)=>{var d,e;const f=null!==(d=null===c||void 0===c?void 0:c.contractAddress)&&void 0!==d?d:CONTRACT_ADDRESS,g=null!==(e=null===c||void 0===c?void 0:c.batchSize)&&void 0!==e?e:BATCH_SIZE,h=await batch(async b=>{const c=encodeWithId(ETHER_BALANCES_ID,ETHER_BALANCES_TYPE,b);return decode(["uint256[]"],await call(a,f,c))[0]},g,b);return toBalanceMap(b,h)};/**
 * Get the ERC-20 token balances of the token with the address `tokenAddress` for the addresses
 * specified.
 *
 * @param {ProviderLike} provider
 * @param {string[]} addresses
 * @param {string} tokenAddress
 * @param {EthScanOptions} options
 * @return {Promise<BalanceMap>}
 */export const getTokenBalances=async(a,b,c,d)=>{var e,f;const g=null!==(e=null===d||void 0===d?void 0:d.contractAddress)&&void 0!==e?e:CONTRACT_ADDRESS,h=null!==(f=null===d||void 0===d?void 0:d.batchSize)&&void 0!==f?f:BATCH_SIZE,i=await batch(async b=>{const d=encodeWithId(TOKEN_BALANCES_ID,TOKEN_BALANCES_TYPE,b,c);return decode(["uint256[]"],await call(a,g,d))[0]},h,b);return toBalanceMap(b,i)};/**
 * Get the ERC-20 token balances for multiple contracts, for multiple addresses. Note that this may fail if there are
 * too many addresses or tokens, and the batch size is too large.
 *
 * @param {ProviderLike} provider
 * @param {string[]} addresses
 * @param {string[]} tokenAddresses
 * @param {EthScanOptions} options
 * @return {Promise<BalanceMap<BalanceMap>>}
 */export const getTokensBalances=async(a,b,c,d)=>{var e,f;const g=null!==(e=null===d||void 0===d?void 0:d.contractAddress)&&void 0!==e?e:CONTRACT_ADDRESS,h=null!==(f=null===d||void 0===d?void 0:d.batchSize)&&void 0!==f?f:BATCH_SIZE,i=await batch(async b=>{const d=encodeWithId(TOKENS_BALANCES_ID,TOKENS_BALANCES_TYPE,b,c);return decode(["uint256[][]"],await call(a,g,d))[0]},h,b);return toNestedBalanceMap(b,c,i)};/**
 * Get the ERC-20 token balance of the tokens with the addresses `tokenAddresses` for the single
 * address specified.
 *
 * @param {ProviderLike} provider
 * @param {string} address
 * @param {string[]} tokenAddresses
 * @param {EthScanOptions} options
 * @return {Promise<BalanceMap>}
 */export const getTokensBalance=async(a,b,c,d)=>{var e,f;const g=null!==(e=null===d||void 0===d?void 0:d.contractAddress)&&void 0!==e?e:CONTRACT_ADDRESS,h=null!==(f=null===d||void 0===d?void 0:d.batchSize)&&void 0!==f?f:BATCH_SIZE,i=await batch(async c=>{const d=encodeWithId(TOKENS_BALANCE_ID,TOKENS_BALANCE_TYPE,b,c);return decode(["uint256[]"],await call(a,g,d))[0]},h,c);return toBalanceMap(c,i)};/**
 * Get a balance map from an array of addresses and an array of balances.
 *
 * @param {string[]} addresses
 * @param {bigint[]} balances
 * @return {BalanceMap}
 */export const toBalanceMap=(a,b)=>b.reduce((b,c,d)=>({...b,[a[d]]:c}),{});/**
 * Get a nested balance map from an array of addresses, token addresses, and balances.
 *
 * @param {string[]} addresses
 * @param {bigint[]} tokenAddresses
 * @param {BalanceMap<BalanceMap>} balances
 */export const toNestedBalanceMap=(a,b,c)=>c.reduce((c,d,e)=>({...c,[a[e]]:toBalanceMap(b,d)}),{});
//# sourceMappingURL=eth-scan.js.map
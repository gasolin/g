{"version":3,"sources":["../../../src/utils/abi.ts"],"names":["decode","decodeAbi","encode","encodeAbi","HEXADECIMAL_CHARACTERS","inputs","data","bufferToString","encodeWithId","id","types","slice","buffer","Uint8Array","reduce","current","next","stringToBuffer","Buffer","from"],"mappings":"AAAA,OAASA,MAAM,GAAIC,CAAAA,SAAnB,CAA8BC,MAAM,GAAIC,CAAAA,SAAxC,KAAyD,cAAzD,CAEA,KAAMC,CAAAA,sBAAsB,CAAG,kBAA/B,CAEA;;;;;;GAOA,MAAO,MAAMF,CAAAA,MAAM,CAAG,CAACG,CAAD,CAAmB,GAAGC,CAAtB,GACbC,cAAc,CAACJ,SAAS,CAACE,CAAD,CAASC,CAAT,CAAV,CADhB,CAIP;;;;;;;GAQA,MAAO,MAAMN,CAAAA,MAAM,CAAG,CAAsBK,CAAtB,CAAwCC,CAAxC,GACbL,SAAS,CAACI,CAAD,CAASC,CAAT,CADX,CAIP;;;;;;;GAQA,MAAO,MAAME,CAAAA,YAAY,CAAG,CAACC,CAAD,CAAaC,CAAb,CAA8B,GAAGJ,CAAjC,GAClB,KAAIG,CAAG,GAAEP,MAAM,CAACQ,CAAD,CAAQ,GAAGJ,CAAX,CAAN,CAAuBK,KAAvB,CAA6B,CAA7B,CAAgC,EAD5C,CAIP;;;;;GAMA,MAAO,MAAMJ,CAAAA,cAAc,CAAIK,CAAD,EACrB,GAAIC,CAAAA,UAAJ,CAAeD,CAAf,EAAuBE,MAAvB,CAAsC,CAACC,CAAD,CAAUC,CAAV,GACpCD,CAAO,CAAGX,sBAAsB,CAACY,CAAI,EAAI,CAAT,CAAhC,CAA8CZ,sBAAsB,CAAQ,EAAP,CAAAY,CAAD,CADtE,CAEJ,IAFI,CADF,CAMP;;;;;GAMA,MAAO,MAAMC,CAAAA,cAAc,CAAIX,CAAD,EACrBY,MAAM,CAACC,IAAP,CAAYb,CAAI,CAACK,KAAL,CAAW,CAAX,CAAZ,CAA2B,KAA3B,CADF","sourcesContent":["import { decode as decodeAbi, encode as encodeAbi } from '@findeth/abi';\n\nconst HEXADECIMAL_CHARACTERS = '0123456789abcdef';\n\n/**\n * Encode the addresses and an optional token to an input data string.\n *\n * @param {string[]} inputs An array of inputs.\n * @param {...any[]} data The arguments as defined by the types.\n * @return {string} The input data formatted as hexadecimal string.\n */\nexport const encode = (inputs: string[], ...data: unknown[]): string => {\n  return bufferToString(encodeAbi(inputs, data));\n};\n\n/**\n * Decode data from a raw Buffer.\n *\n * @param {string[]} inputs An array of inputs.\n * @param {Buffer} data The Buffer to decode.\n * @return {T} The decoded data.\n * @template T\n */\nexport const decode = <T extends unknown[]>(inputs: string[], data: Buffer): T => {\n  return decodeAbi(inputs, data);\n};\n\n/**\n * Encode the addresses and an optional token to an input data string with the function identifier.\n *\n * @param {string} id The function identifier as a hexadecimal string.\n * @param {string[]} types An array of inputs.\n * @param {...any[]} data The arguments as defined by the types.\n * @return {string} The input data as a hexadecimal string.\n */\nexport const encodeWithId = (id: string, types: string[], ...data: unknown[]): string => {\n  return `0x${id}${encode(types, ...data).slice(2)}`;\n};\n\n/**\n * Get the buffer as hexadecimal string, prefixed with 0x.\n *\n * @param {Buffer} buffer The buffer to encode.\n * @return {string} The hexadecimal string.\n */\nexport const bufferToString = (buffer: Buffer | Uint8Array): string => {\n  return new Uint8Array(buffer).reduce<string>((current, next) => {\n    return current + HEXADECIMAL_CHARACTERS[next >> 4] + HEXADECIMAL_CHARACTERS[next & 15];\n  }, '0x');\n};\n\n/**\n * Get a buffer from a hexadecimal string.\n *\n * @param {string} data The hexadecimal string including the 0x prefix.\n * @return {Buffer} A Buffer of the hexadecimal string.\n */\nexport const stringToBuffer = (data: string): Buffer => {\n  return Buffer.from(data.slice(2), 'hex');\n};\n"],"file":"abi.js"}
{"version":3,"sources":["../../src/eth-scan.ts"],"names":["getEtherBalances","provider","addresses","options","contractAddress","CONTRACT_ADDRESS","batchSize","BATCH_SIZE","balances","batchedAddresses","data","ETHER_BALANCES_ID","ETHER_BALANCES_TYPE","toBalanceMap","getTokenBalances","tokenAddress","TOKEN_BALANCES_ID","TOKEN_BALANCES_TYPE","getTokensBalances","tokenAddresses","TOKENS_BALANCES_ID","TOKENS_BALANCES_TYPE","toNestedBalanceMap","getTokensBalance","address","TOKENS_BALANCE_ID","TOKENS_BALANCE_TYPE","reduce","current","next","index"],"mappings":"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","sourcesContent":["import {\n  BATCH_SIZE,\n  CONTRACT_ADDRESS,\n  ETHER_BALANCES_ID,\n  ETHER_BALANCES_TYPE,\n  TOKEN_BALANCES_ID,\n  TOKEN_BALANCES_TYPE,\n  TOKENS_BALANCE_ID,\n  TOKENS_BALANCE_TYPE,\n  TOKENS_BALANCES_ID,\n  TOKENS_BALANCES_TYPE\n} from './constants';\nimport { call, ProviderLike } from './providers';\nimport { batch, decode, encodeWithId } from './utils';\n\n/**\n * An object that contains the address (key) and balance or balance (value).\n */\nexport interface BalanceMap<T = bigint> {\n  [key: string]: T;\n}\n\nexport interface EthScanOptions {\n  /**\n   * The address of the contract to use. Defaults to 0xbb4AAaF8cAA1A575B43E7673e5b155C1c5A8BC13.\n   */\n  contractAddress?: string;\n\n  /**\n   * It's not possible to check thousands of addresses at the same time, due to gas limitations.\n   * Calls are split per `batchSize` addresses, by default set to 1000.\n   */\n  batchSize?: number;\n}\n\n/**\n * Get the Ether balances for the addresses specified.\n *\n * @param {ProviderLike} provider\n * @param {string[]} addresses\n * @param {EthScanOptions} options\n * @return {Promise<BalanceMap>}\n */\nexport const getEtherBalances = async (\n  provider: ProviderLike,\n  addresses: string[],\n  options?: EthScanOptions\n): Promise<BalanceMap> => {\n  const contractAddress = options?.contractAddress ?? CONTRACT_ADDRESS;\n  const batchSize = options?.batchSize ?? BATCH_SIZE;\n\n  const balances = await batch(\n    async (batchedAddresses: string[]) => {\n      const data = encodeWithId(ETHER_BALANCES_ID, ETHER_BALANCES_TYPE, batchedAddresses);\n\n      return decode<[Array<bigint>]>(['uint256[]'], await call(provider, contractAddress, data))[0];\n    },\n    batchSize,\n    addresses\n  );\n\n  return toBalanceMap(addresses, balances);\n};\n\n/**\n * Get the ERC-20 token balances of the token with the address `tokenAddress` for the addresses\n * specified.\n *\n * @param {ProviderLike} provider\n * @param {string[]} addresses\n * @param {string} tokenAddress\n * @param {EthScanOptions} options\n * @return {Promise<BalanceMap>}\n */\nexport const getTokenBalances = async (\n  provider: ProviderLike,\n  addresses: string[],\n  tokenAddress: string,\n  options?: EthScanOptions\n): Promise<BalanceMap> => {\n  const contractAddress = options?.contractAddress ?? CONTRACT_ADDRESS;\n  const batchSize = options?.batchSize ?? BATCH_SIZE;\n\n  const balances = await batch(\n    async (batchedAddresses: string[]) => {\n      const data = encodeWithId(TOKEN_BALANCES_ID, TOKEN_BALANCES_TYPE, batchedAddresses, tokenAddress);\n\n      return decode<[Array<bigint>]>(['uint256[]'], await call(provider, contractAddress, data))[0];\n    },\n    batchSize,\n    addresses\n  );\n\n  return toBalanceMap(addresses, balances);\n};\n\n/**\n * Get the ERC-20 token balances for multiple contracts, for multiple addresses. Note that this may fail if there are\n * too many addresses or tokens, and the batch size is too large.\n *\n * @param {ProviderLike} provider\n * @param {string[]} addresses\n * @param {string[]} tokenAddresses\n * @param {EthScanOptions} options\n * @return {Promise<BalanceMap<BalanceMap>>}\n */\nexport const getTokensBalances = async (\n  provider: ProviderLike,\n  addresses: string[],\n  tokenAddresses: string[],\n  options?: EthScanOptions\n): Promise<BalanceMap<BalanceMap>> => {\n  const contractAddress = options?.contractAddress ?? CONTRACT_ADDRESS;\n  const batchSize = options?.batchSize ?? BATCH_SIZE;\n\n  const balances = await batch<Array<bigint>>(\n    async (batchedAddresses: string[]) => {\n      const data = encodeWithId(TOKENS_BALANCES_ID, TOKENS_BALANCES_TYPE, batchedAddresses, tokenAddresses);\n\n      return decode<[Array<Array<bigint>>]>(['uint256[][]'], await call(provider, contractAddress, data))[0];\n    },\n    batchSize,\n    addresses\n  );\n\n  return toNestedBalanceMap(addresses, tokenAddresses, balances);\n};\n\n/**\n * Get the ERC-20 token balance of the tokens with the addresses `tokenAddresses` for the single\n * address specified.\n *\n * @param {ProviderLike} provider\n * @param {string} address\n * @param {string[]} tokenAddresses\n * @param {EthScanOptions} options\n * @return {Promise<BalanceMap>}\n */\nexport const getTokensBalance = async (\n  provider: ProviderLike,\n  address: string,\n  tokenAddresses: string[],\n  options?: EthScanOptions\n): Promise<BalanceMap> => {\n  const contractAddress = options?.contractAddress ?? CONTRACT_ADDRESS;\n  const batchSize = options?.batchSize ?? BATCH_SIZE;\n\n  const balances = await batch(\n    async (batchedAddresses: string[]) => {\n      const data = encodeWithId(TOKENS_BALANCE_ID, TOKENS_BALANCE_TYPE, address, batchedAddresses);\n\n      return decode<[Array<bigint>]>(['uint256[]'], await call(provider, contractAddress, data))[0];\n    },\n    batchSize,\n    tokenAddresses\n  );\n\n  return toBalanceMap(tokenAddresses, balances);\n};\n\n/**\n * Get a balance map from an array of addresses and an array of balances.\n *\n * @param {string[]} addresses\n * @param {bigint[]} balances\n * @return {BalanceMap}\n */\nexport const toBalanceMap = (addresses: string[], balances: Array<bigint>): BalanceMap => {\n  return balances.reduce<BalanceMap>((current, next, index) => {\n    return {\n      ...current,\n      [addresses[index]]: next\n    };\n  }, {});\n};\n\n/**\n * Get a nested balance map from an array of addresses, token addresses, and balances.\n *\n * @param {string[]} addresses\n * @param {bigint[]} tokenAddresses\n * @param {BalanceMap<BalanceMap>} balances\n */\nexport const toNestedBalanceMap = (\n  addresses: string[],\n  tokenAddresses: string[],\n  balances: Array<Array<bigint>>\n): BalanceMap<BalanceMap> => {\n  return balances.reduce<BalanceMap<BalanceMap>>((current, next, index) => {\n    return {\n      ...current,\n      [addresses[index]]: toBalanceMap(tokenAddresses, next)\n    };\n  }, {});\n};\n"],"file":"eth-scan.js"}
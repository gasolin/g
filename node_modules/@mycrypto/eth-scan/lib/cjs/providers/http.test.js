"use strict";var _buidler=require("@nomiclabs/buidler"),_constants=require("../constants"),_ethScan=require("../eth-scan.test"),_utils=require("../utils"),_http=require("./http");jest.mock("isomorphic-unfetch");const{loadFixture}=_buidler.waffle;describe("isHttpProvider",()=>{it("checks if a provider is an HTTP provider",()=>{expect((0,_http.isHttpProvider)("https://foo")).toBe(!0),expect((0,_http.isHttpProvider)({url:"https://foo"})).toBe(!0),expect((0,_http.isHttpProvider)({})).toBe(!1)})}),describe("callWithHttp",()=>{it("gets the Ether balances from the contract",async()=>{const{contract:a,addresses:b}=await loadFixture(_ethScan.fixture),c=(0,_utils.encodeWithId)(_constants.ETHER_BALANCES_ID,_constants.ETHER_BALANCES_TYPE,b),d=await(0,_http.callWithHttp)(_buidler.ethers.provider.connection.url,a.address,c),e=(0,_utils.decode)(["uint256[]"],d)[0];for(let a=0;a<b.length;a++){const c=BigInt((await _buidler.ethers.provider.getBalance(b[a])).toHexString());expect(c).toBe(e[a])}}),it("gets the token balances from the contract",async()=>{const{contract:a,addresses:b,token:c}=await loadFixture(_ethScan.fixture);await c.mock.balanceOf.returns("1000");const d=(0,_utils.encodeWithId)(_constants.TOKEN_BALANCES_ID,_constants.TOKEN_BALANCES_TYPE,b,c.address),e=await(0,_http.callWithHttp)(_buidler.ethers.provider.connection.url,a.address,d),f=(0,_utils.decode)(["uint256[]"],e)[0];for(let a=0;a<b.length;a++)expect(f[a]).toBe(1000n)})});
//# sourceMappingURL=http.test.js.map
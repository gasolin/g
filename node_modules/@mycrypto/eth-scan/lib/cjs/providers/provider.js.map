{"version":3,"sources":["../../../src/providers/provider.ts"],"names":["call","provider","contractAddress","data","Error"],"mappings":"uKAMA;;;;;;;;GASO,KAAMA,CAAAA,IAAI,CAAG,MAAOC,CAAP,CAA+BC,CAA/B,CAAwDC,CAAxD,GAA0F,CAC5G,GAAI,6BAAiBF,CAAjB,CAAJ,CACE,MAAO,2BAAeA,CAAf,CAAyBC,CAAzB,CAA0CC,CAA1C,CAAP,CAGF,GAAI,yBAAeF,CAAf,CAAJ,CACE,MAAO,uBAAaA,CAAb,CAAuBC,CAAvB,CAAwCC,CAAxC,CAAP,CAGF,GAAI,wBAAeF,CAAf,CAAJ,CACE,MAAO,sBAAaA,CAAb,CAAuBC,CAAvB,CAAwCC,CAAxC,CAAP,CAGF,KAAM,IAAIC,CAAAA,KAAJ,CAAU,4BAAV,CACP,CAdM,C","sourcesContent":["import { callWithEthers, EthersProviderLike, isEthersProvider } from './ethers';\nimport { callWithHttp, HttpProviderLike, isHttpProvider } from './http';\nimport { callWithWeb3, isWeb3Provider, Web3ProviderLike } from './web3';\n\nexport type ProviderLike = HttpProviderLike | EthersProviderLike | Web3ProviderLike;\n\n/**\n * Send a call with the data, using the specified provider. If the provider is not a valid provider type (e.g. not a\n * Ethers.js provider, URL or Web3 provider), this will throw an error.\n *\n * @param {ProviderLike} provider\n * @param {string} contractAddress\n * @param {string} data\n * @return {Promise<Buffer>}\n */\nexport const call = async (provider: ProviderLike, contractAddress: string, data: string): Promise<Buffer> => {\n  if (isEthersProvider(provider)) {\n    return callWithEthers(provider, contractAddress, data);\n  }\n\n  if (isHttpProvider(provider)) {\n    return callWithHttp(provider, contractAddress, data);\n  }\n\n  if (isWeb3Provider(provider)) {\n    return callWithWeb3(provider, contractAddress, data);\n  }\n\n  throw new Error('Invalid provider specified');\n};\n"],"file":"provider.js"}
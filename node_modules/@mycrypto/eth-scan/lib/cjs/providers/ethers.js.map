{"version":3,"sources":["../../../src/providers/ethers.ts"],"names":["isEthersProvider","provider","call","callWithEthers","contractAddress","data","to","error","Error","message","toString"],"mappings":"aAAA,+B,8GAaA;;;;;GAMO,KAAMA,CAAAA,gBAAgB,CAAIC,CAAD,EACvB,iBAACA,CAAD,WAACA,CAAD,QAACA,CAAD,CAAkCC,IAAlC,CADF,CAIP;;;;;;;6CAQO,KAAMC,CAAAA,cAAc,CAAG,MAC5BF,CAD4B,CAE5BG,CAF4B,CAG5BC,CAH4B,GAIR,CAMpB,GAAI,CACF,MAAO,0BAAe,KAAMJ,CAAAA,CAAQ,CAACC,IAAT,CANU,CACtCI,EAAE,CAAEF,CADkC,CAEtCC,IAAI,CAAJA,CAFsC,CAMV,CAA2B,QAA3B,CAArB,CACR,CAAC,MAAOE,CAAP,CAAc,OACd,KAAM,IAAIC,CAAAA,KAAJ,CAAW,yBAAD,UAAyBD,CAAK,CAACE,OAA/B,gBAA0CF,CAAK,CAACG,QAAN,EAAiB,EAArE,CACP,CACF,CAfM,C","sourcesContent":["import { stringToBuffer } from '../utils';\n\ntype BlockTag = string | number;\n\ninterface TransactionRequest {\n  to: string;\n  data: string;\n}\n\nexport interface EthersProviderLike {\n  call(transaction: TransactionRequest, blockTag?: BlockTag | Promise<BlockTag>): Promise<string>;\n}\n\n/**\n * Check if an object is a valid EthersProviderLike object.\n *\n * @param {any} provider\n * @return {boolean}\n */\nexport const isEthersProvider = (provider: unknown): provider is EthersProviderLike => {\n  return (provider as EthersProviderLike)?.call !== undefined;\n};\n\n/**\n * Call the contract with an Ethers provider. This throws an error if the call failed.\n *\n * @param {EthersProviderLike} provider\n * @param {string} contractAddress\n * @param {string} data\n * @return {Promise<Buffer>}\n */\nexport const callWithEthers = async (\n  provider: EthersProviderLike,\n  contractAddress: string,\n  data: string\n): Promise<Buffer> => {\n  const transaction: TransactionRequest = {\n    to: contractAddress,\n    data\n  };\n\n  try {\n    return stringToBuffer(await provider.call(transaction, 'latest'));\n  } catch (error) {\n    throw new Error(`Contract call failed: ${error.message ?? error.toString()}`);\n  }\n};\n"],"file":"ethers.js"}
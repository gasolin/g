"use strict";var _buidler=require("@nomiclabs/buidler"),_web=_interopRequireDefault(require("web3")),_constants=require("../constants"),_ethScan=require("../eth-scan.test"),_utils=require("../utils"),_web2=require("./web3");function _interopRequireDefault(a){return a&&a.__esModule?a:{default:a}}jest.mock("web3");const{loadFixture}=_buidler.waffle;describe("isWeb3Provider",()=>{it("checks if a provider is an HTTP provider",()=>{expect((0,_web2.isWeb3Provider)({currentProvider:{send(){/* noop */}}})).toBe(!0),expect((0,_web2.isWeb3Provider)({})).toBe(!1)})}),describe("callWithWeb3",()=>{const a=new _web.default(_buidler.ethers.provider.connection.url);it("gets the Ether balances from the contract",async()=>{const{contract:b,addresses:c}=await loadFixture(_ethScan.fixture),d=(0,_utils.encodeWithId)(_constants.ETHER_BALANCES_ID,_constants.ETHER_BALANCES_TYPE,c),e=await(0,_web2.callWithWeb3)(a,b.address,d),f=(0,_utils.decode)(["uint256[]"],e)[0];for(let a=0;a<c.length;a++){const b=BigInt((await _buidler.ethers.provider.getBalance(c[a])).toHexString());expect(b).toBe(f[a])}}),it("gets the token balances from the contract",async()=>{const{contract:b,addresses:c,token:d}=await loadFixture(_ethScan.fixture);await d.mock.balanceOf.returns("1000");const e=(0,_utils.encodeWithId)(_constants.TOKEN_BALANCES_ID,_constants.TOKEN_BALANCES_TYPE,c,d.address),f=await(0,_web2.callWithWeb3)(a,b.address,e),g=(0,_utils.decode)(["uint256[]"],f)[0];for(let a=0;a<c.length;a++)expect(g[a]).toBe(1000n)})});
//# sourceMappingURL=web3.test.js.map
{"version":3,"sources":["../../../src/utils/abi.ts"],"names":["HEXADECIMAL_CHARACTERS","encode","inputs","data","bufferToString","decode","encodeWithId","id","types","slice","buffer","Uint8Array","reduce","current","next","stringToBuffer","Buffer","from"],"mappings":"aAAA,iC,oKAEMA,CAAAA,sBAAsB,CAAG,kB,CASlBC,MAAM,CAAG,CAACC,CAAD,CAAmB,GAAGC,CAAtB,GACbC,cAAc,CAAC,gBAAUF,CAAV,CAAkBC,CAAlB,CAAD,C,CARvB;;;;;;yBAWA;;;;;;;GAQO,KAAME,CAAAA,MAAM,CAAG,CAAsBH,CAAtB,CAAwCC,CAAxC,GACb,gBAAUD,CAAV,CAAkBC,CAAlB,CADF,CAIP;;;;;;;yBAQO,KAAMG,CAAAA,YAAY,CAAG,CAACC,CAAD,CAAaC,CAAb,CAA8B,GAAGL,CAAjC,GAClB,KAAII,CAAG,GAAEN,MAAM,CAACO,CAAD,CAAQ,GAAGL,CAAX,CAAN,CAAuBM,KAAvB,CAA6B,CAA7B,CAAgC,EAD5C,CAIP;;;;;qCAMO,KAAML,CAAAA,cAAc,CAAIM,CAAD,EACrB,GAAIC,CAAAA,UAAJ,CAAeD,CAAf,EAAuBE,MAAvB,CAAsC,CAACC,CAAD,CAAUC,CAAV,GACpCD,CAAO,CAAGb,sBAAsB,CAACc,CAAI,EAAI,CAAT,CAAhC,CAA8Cd,sBAAsB,CAAQ,EAAP,CAAAc,CAAD,CADtE,CAEJ,IAFI,CADF,CAMP;;;;;yCAMO,KAAMC,CAAAA,cAAc,CAAIZ,CAAD,EACrBa,MAAM,CAACC,IAAP,CAAYd,CAAI,CAACM,KAAL,CAAW,CAAX,CAAZ,CAA2B,KAA3B,CADF,C","sourcesContent":["import { decode as decodeAbi, encode as encodeAbi } from '@findeth/abi';\n\nconst HEXADECIMAL_CHARACTERS = '0123456789abcdef';\n\n/**\n * Encode the addresses and an optional token to an input data string.\n *\n * @param {string[]} inputs An array of inputs.\n * @param {...any[]} data The arguments as defined by the types.\n * @return {string} The input data formatted as hexadecimal string.\n */\nexport const encode = (inputs: string[], ...data: unknown[]): string => {\n  return bufferToString(encodeAbi(inputs, data));\n};\n\n/**\n * Decode data from a raw Buffer.\n *\n * @param {string[]} inputs An array of inputs.\n * @param {Buffer} data The Buffer to decode.\n * @return {T} The decoded data.\n * @template T\n */\nexport const decode = <T extends unknown[]>(inputs: string[], data: Buffer): T => {\n  return decodeAbi(inputs, data);\n};\n\n/**\n * Encode the addresses and an optional token to an input data string with the function identifier.\n *\n * @param {string} id The function identifier as a hexadecimal string.\n * @param {string[]} types An array of inputs.\n * @param {...any[]} data The arguments as defined by the types.\n * @return {string} The input data as a hexadecimal string.\n */\nexport const encodeWithId = (id: string, types: string[], ...data: unknown[]): string => {\n  return `0x${id}${encode(types, ...data).slice(2)}`;\n};\n\n/**\n * Get the buffer as hexadecimal string, prefixed with 0x.\n *\n * @param {Buffer} buffer The buffer to encode.\n * @return {string} The hexadecimal string.\n */\nexport const bufferToString = (buffer: Buffer | Uint8Array): string => {\n  return new Uint8Array(buffer).reduce<string>((current, next) => {\n    return current + HEXADECIMAL_CHARACTERS[next >> 4] + HEXADECIMAL_CHARACTERS[next & 15];\n  }, '0x');\n};\n\n/**\n * Get a buffer from a hexadecimal string.\n *\n * @param {string} data The hexadecimal string including the 0x prefix.\n * @return {Buffer} A Buffer of the hexadecimal string.\n */\nexport const stringToBuffer = (data: string): Buffer => {\n  return Buffer.from(data.slice(2), 'hex');\n};\n"],"file":"abi.js"}
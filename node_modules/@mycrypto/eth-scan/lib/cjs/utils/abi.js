"use strict";var _abi=require("@findeth/abi");Object.defineProperty(exports,"__esModule",{value:!0}),exports.stringToBuffer=exports.bufferToString=exports.encodeWithId=exports.decode=exports.encode=void 0;const HEXADECIMAL_CHARACTERS="0123456789abcdef",encode=(a,...b)=>bufferToString((0,_abi.encode)(a,b));/**
 * Encode the addresses and an optional token to an input data string.
 *
 * @param {string[]} inputs An array of inputs.
 * @param {...any[]} data The arguments as defined by the types.
 * @return {string} The input data formatted as hexadecimal string.
 */exports.encode=encode;/**
 * Decode data from a raw Buffer.
 *
 * @param {string[]} inputs An array of inputs.
 * @param {Buffer} data The Buffer to decode.
 * @return {T} The decoded data.
 * @template T
 */const decode=(a,b)=>(0,_abi.decode)(a,b);/**
 * Encode the addresses and an optional token to an input data string with the function identifier.
 *
 * @param {string} id The function identifier as a hexadecimal string.
 * @param {string[]} types An array of inputs.
 * @param {...any[]} data The arguments as defined by the types.
 * @return {string} The input data as a hexadecimal string.
 */exports.decode=decode;const encodeWithId=(a,b,...c)=>`0x${a}${encode(b,...c).slice(2)}`;/**
 * Get the buffer as hexadecimal string, prefixed with 0x.
 *
 * @param {Buffer} buffer The buffer to encode.
 * @return {string} The hexadecimal string.
 */exports.encodeWithId=encodeWithId;const bufferToString=a=>new Uint8Array(a).reduce((a,b)=>a+HEXADECIMAL_CHARACTERS[b>>4]+HEXADECIMAL_CHARACTERS[15&b],"0x");/**
 * Get a buffer from a hexadecimal string.
 *
 * @param {string} data The hexadecimal string including the 0x prefix.
 * @return {Buffer} A Buffer of the hexadecimal string.
 */exports.bufferToString=bufferToString;const stringToBuffer=a=>Buffer.from(a.slice(2),"hex");exports.stringToBuffer=stringToBuffer;
//# sourceMappingURL=abi.js.map
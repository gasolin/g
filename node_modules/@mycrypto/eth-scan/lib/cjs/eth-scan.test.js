"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.fixture=void 0;var _buidler=require("@nomiclabs/buidler"),_IERC=_interopRequireDefault(require("openzeppelin-solidity/build/contracts/IERC20.json")),_BalanceScanner=_interopRequireDefault(require("../artifacts/BalanceScanner.json")),_ethScan=require("./eth-scan");function _interopRequireDefault(a){return a&&a.__esModule?a:{default:a}}const{deployContract,deployMockContract,loadFixture}=_buidler.waffle,fixture=async(a,b)=>{const c=a[0],d=await deployContract(c,_BalanceScanner.default),e=await deployMockContract(c,_IERC.default.abi),f=await Promise.all(a.slice(1).map(a=>a.getAddress()));return{contract:d,signers:a,addresses:f,provider:b,token:e}};// eslint-disable-next-line jest/no-export
exports.fixture=fixture,describe("eth-scan",()=>{describe("getEtherBalances",()=>{it("returns the ether balances for multiple addresses as a BalanceMap",async()=>{const{contract:a,addresses:b}=await loadFixture(fixture),c=await(0,_ethScan.getEtherBalances)(_buidler.ethers.provider,b,{contractAddress:a.address});for(const a of b){const b=BigInt((await _buidler.ethers.provider.getBalance(a)).toHexString());expect(b).toBe(c[a])}})}),describe("getTokenBalances",()=>{it("returns the token balances of one token, for multiple addresses",async()=>{const{contract:a,addresses:b,token:c}=await loadFixture(fixture);await c.mock.balanceOf.returns("1000");const d=await(0,_ethScan.getTokenBalances)(_buidler.ethers.provider,b,c.address,{contractAddress:a.address});for(const a of b)expect(d[a]).toBe(1000n)}),it("does not throw for invalid contracts",async()=>{const{contract:a,addresses:b,token:c}=await loadFixture(fixture);await expect(()=>(0,_ethScan.getTokenBalances)(_buidler.ethers.provider,b,c.address,{contractAddress:a.address})).not.toThrow()})}),describe("getTokensBalances",()=>{it("returns multiple token balances, for multiple addresses",async()=>{const{contract:a,signers:b,addresses:c}=await loadFixture(fixture),d=await deployMockContract(b[0],_IERC.default.abi);await d.mock.balanceOf.returns("1000");const e=await deployMockContract(b[0],_IERC.default.abi);await e.mock.balanceOf.returns("1");const f=await(0,_ethScan.getTokensBalances)(_buidler.ethers.provider,c,[d.address,e.address],{contractAddress:a.address});for(const a of c)expect(Object.keys(f[a])).toHaveLength(2),expect(Object.keys(f[a])[0]).toBe(d.address),expect(Object.keys(f[a])[1]).toBe(e.address),expect(f[a][d.address]).toBe(1000n),expect(f[a][e.address]).toBe(1n)}),it("does not throw for invalid contracts",async()=>{const{contract:a,signers:b,addresses:c}=await loadFixture(fixture),d=await deployMockContract(b[0],_IERC.default.abi),e=await deployMockContract(b[0],_IERC.default.abi);await expect(()=>(0,_ethScan.getTokensBalances)(_buidler.ethers.provider,c,[d.address,e.address],{contractAddress:a.address})).not.toThrow()})}),describe("getTokensBalance",()=>{it("returns multiple token balances for a single address",async()=>{const{contract:a,signers:b,addresses:c}=await loadFixture(fixture),d=await deployMockContract(b[0],_IERC.default.abi);await d.mock.balanceOf.returns("1000");const e=await deployMockContract(b[0],_IERC.default.abi);await e.mock.balanceOf.returns("1");const f=await(0,_ethScan.getTokensBalance)(_buidler.ethers.provider,c[0],[d.address,e.address],{contractAddress:a.address});expect(Object.keys(f)).toHaveLength(2),expect(Object.keys(f)[0]).toBe(d.address),expect(Object.keys(f)[1]).toBe(e.address),expect(f[d.address]).toBe(1000n),expect(f[e.address]).toBe(1n)}),it("does not throw for invalid contracts",async()=>{const{contract:a,signers:b,addresses:c}=await loadFixture(fixture),d=await deployMockContract(b[0],_IERC.default.abi),e=await deployMockContract(b[0],_IERC.default.abi);await expect(()=>(0,_ethScan.getTokensBalance)(_buidler.ethers.provider,c[0],[d.address,e.address],{contractAddress:a.address})).not.toThrow()})})});
//# sourceMappingURL=eth-scan.test.js.map
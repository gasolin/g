"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.toNestedBalanceMap=exports.toBalanceMap=exports.getTokensBalance=exports.getTokensBalances=exports.getTokenBalances=exports.getEtherBalances=void 0;var _constants=require("./constants"),_providers=require("./providers"),_utils=require("./utils");/**
 * Get the Ether balances for the addresses specified.
 *
 * @param {ProviderLike} provider
 * @param {string[]} addresses
 * @param {EthScanOptions} options
 * @return {Promise<BalanceMap>}
 */const getEtherBalances=async(a,b,c)=>{var d,e;const f=null!==(d=null===c||void 0===c?void 0:c.contractAddress)&&void 0!==d?d:_constants.CONTRACT_ADDRESS,g=null!==(e=null===c||void 0===c?void 0:c.batchSize)&&void 0!==e?e:_constants.BATCH_SIZE,h=await(0,_utils.batch)(async b=>{const c=(0,_utils.encodeWithId)(_constants.ETHER_BALANCES_ID,_constants.ETHER_BALANCES_TYPE,b);return(0,_utils.decode)(["uint256[]"],await(0,_providers.call)(a,f,c))[0]},g,b);return toBalanceMap(b,h)};/**
 * Get the ERC-20 token balances of the token with the address `tokenAddress` for the addresses
 * specified.
 *
 * @param {ProviderLike} provider
 * @param {string[]} addresses
 * @param {string} tokenAddress
 * @param {EthScanOptions} options
 * @return {Promise<BalanceMap>}
 */exports.getEtherBalances=getEtherBalances;const getTokenBalances=async(a,b,c,d)=>{var e,f;const g=null!==(e=null===d||void 0===d?void 0:d.contractAddress)&&void 0!==e?e:_constants.CONTRACT_ADDRESS,h=null!==(f=null===d||void 0===d?void 0:d.batchSize)&&void 0!==f?f:_constants.BATCH_SIZE,i=await(0,_utils.batch)(async b=>{const d=(0,_utils.encodeWithId)(_constants.TOKEN_BALANCES_ID,_constants.TOKEN_BALANCES_TYPE,b,c);return(0,_utils.decode)(["uint256[]"],await(0,_providers.call)(a,g,d))[0]},h,b);return toBalanceMap(b,i)};/**
 * Get the ERC-20 token balances for multiple contracts, for multiple addresses. Note that this may fail if there are
 * too many addresses or tokens, and the batch size is too large.
 *
 * @param {ProviderLike} provider
 * @param {string[]} addresses
 * @param {string[]} tokenAddresses
 * @param {EthScanOptions} options
 * @return {Promise<BalanceMap<BalanceMap>>}
 */exports.getTokenBalances=getTokenBalances;const getTokensBalances=async(a,b,c,d)=>{var e,f;const g=null!==(e=null===d||void 0===d?void 0:d.contractAddress)&&void 0!==e?e:_constants.CONTRACT_ADDRESS,h=null!==(f=null===d||void 0===d?void 0:d.batchSize)&&void 0!==f?f:_constants.BATCH_SIZE,i=await(0,_utils.batch)(async b=>{const d=(0,_utils.encodeWithId)(_constants.TOKENS_BALANCES_ID,_constants.TOKENS_BALANCES_TYPE,b,c);return(0,_utils.decode)(["uint256[][]"],await(0,_providers.call)(a,g,d))[0]},h,b);return toNestedBalanceMap(b,c,i)};/**
 * Get the ERC-20 token balance of the tokens with the addresses `tokenAddresses` for the single
 * address specified.
 *
 * @param {ProviderLike} provider
 * @param {string} address
 * @param {string[]} tokenAddresses
 * @param {EthScanOptions} options
 * @return {Promise<BalanceMap>}
 */exports.getTokensBalances=getTokensBalances;const getTokensBalance=async(a,b,c,d)=>{var e,f;const g=null!==(e=null===d||void 0===d?void 0:d.contractAddress)&&void 0!==e?e:_constants.CONTRACT_ADDRESS,h=null!==(f=null===d||void 0===d?void 0:d.batchSize)&&void 0!==f?f:_constants.BATCH_SIZE,i=await(0,_utils.batch)(async c=>{const d=(0,_utils.encodeWithId)(_constants.TOKENS_BALANCE_ID,_constants.TOKENS_BALANCE_TYPE,b,c);return(0,_utils.decode)(["uint256[]"],await(0,_providers.call)(a,g,d))[0]},h,c);return toBalanceMap(c,i)};/**
 * Get a balance map from an array of addresses and an array of balances.
 *
 * @param {string[]} addresses
 * @param {bigint[]} balances
 * @return {BalanceMap}
 */exports.getTokensBalance=getTokensBalance;const toBalanceMap=(a,b)=>b.reduce((b,c,d)=>({...b,[a[d]]:c}),{});/**
 * Get a nested balance map from an array of addresses, token addresses, and balances.
 *
 * @param {string[]} addresses
 * @param {bigint[]} tokenAddresses
 * @param {BalanceMap<BalanceMap>} balances
 */exports.toBalanceMap=toBalanceMap;const toNestedBalanceMap=(a,b,c)=>c.reduce((c,d,e)=>({...c,[a[e]]:toBalanceMap(b,d)}),{});exports.toNestedBalanceMap=toNestedBalanceMap;
//# sourceMappingURL=eth-scan.js.map